# 证明系统

***证明系统*** 的目标是能够证明有趣的数学或密码学语句.

通常，在给定的协议中，我们想要证明不同于它们的公共输入的语句族。
证明者需要展示他们知道一些隐私输入来使语句成立

为了做到上面所说的, 我们描绘了一个***关系式***, $\mathcal{R}$, 
这个关系式指定哪些公共输入和隐私输入组合是有效的。


> 上面的术语和 [ZKProof Community Reference](https://docs.zkproof.org/reference#latest-version) 是一致的

准确地说，我们应该区分关系式 $\mathcal{R}$ 和它在证明系统中使用的实现。我们称后者为电路。



我们用来表示特定证明系统的电路的语言叫做***arithmetization***。
通常，一个算法会在多项式约束条件下定义电路,多项式中的变量在一个域中 。



> 表达一个特定关系的过程叫做电路, 有时也叫作 "算法", 但是我们避免这种称呼.


为了去创建一个语句的proof, 证明者需要知道 private input, 还有电路使用的中间值，又称为***通知***值。


我们假设我们能高效的通过公开输入和隐私输入计算通知值.
具体的通知值依赖于于我们如何编写电路，而不仅仅取决于高级语句。



隐私输入和通知值共同叫做 ***witness***



> 有些作者在写 隐私输入时使用witness, 但是在我们的使用中, witness还包括 通知值, 
> 即它包括证明者提供给电路的所有值。 


举个例子, 假设我们想证明原像 $x$ 经过 hash函数 $H$ 所得到 $y$


* 隐私输入是 原像 $x$


* 公开输入是 $y$


* 关系式为 $\{(x, y) : H(x) = y\}$.


* 对于特定的公共输入 $Y$, 语句是$\{(x) : H(x) = Y\}$.


* advice是实现哈希函数的电路中的所有中间值。witness是$x$和advice。


***非交互式argument***允许prover给给定的语句和witness创建一个proof.
证明是一个可以使验证者确信存在witness 并使数据成立的数据.
这种证明不能错误地说服一个验证者的安全特性称为可靠性。


***非交互式证明***(***NARK***)进一步使验证者确信证明者知道使语句成立的witness.
这个安全属性称为***知识可靠性***，它暗示了可靠性。



在实践中，知识的可靠性对于密码协议比可靠性更有用 :
如果我们对Alice是否在某个协议中持有密钥感兴趣，我们需要Alice证明她知道密钥，而不仅仅是密钥存在。


知识的可靠性是通过一个***提取器***来形式化的，它可以精确地观察证明是如何生成的，能够计算witness。

> 这个性质是微妙的，因为证明是可塑的。 
> 也就是说，根据证明系统，可以采用现有的证明(或者证明集)
> 在不知道witness的情况下，修改witness 生成一个明显相同的证明或者是一个有关的语句.
> 修改证人的陈述，以提供有关陈述的清晰证明。
> 使用可塑证明系统的高级协议需要考虑到这一点.

> 即使没有可塑性, 证明也很可能***回放***, 举个例子,
> 我们不希望在我们的例子中Alice能够提交别人生成的证明，并将其作为她知道密钥的证明。

如果一个证明中没有关于witness的信息(除此之外, witness存在并且prover 知道witness), 
这时我们说证明系统是 ***零知识的***

如果证明系统生成了简短的证明, 即 电路的多重对数级长度 
那么我们说这是 ***简洁的***
一个简洁的***NARK*** 叫做 ***snark***(***简洁的非交互式证明***)

> 根据这个定义, 一个SNARK 不需要关于电路大小的多项式对数级验证时间.
> 有些论文使用术语***efficient***来描述具有这种性质的SNARK，
> 但我们将避免使用这个术语，因为它对于支持平摊或递归验证的SNARKs来说是语义是模糊的，我们稍后会讲到


***zk-SNARK*** 叫做零知识证明


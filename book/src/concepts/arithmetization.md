# PLONK化算术化

halo2采用的算术化来自于 [PLONK](https://eprint.iacr.org/2019/953)，或者更准确地说，来自它的扩展UltraPLONK，支持自定义门和查找表。我们称之为PLONK化（ [***PLONKish***](https://twitter.com/feministPLT/status/1413815927704014850)）。

***PLONK化电路***是用矩形矩阵定义的。矩阵的***行***，***列***，***单元格*** 和传统矩阵叫法意义一致。

PLONK化电路依赖***配置*** （configuation）：

* 一个有限域$\mathbb{F}$，其中单元格的值(给定论述和论据)是$\mathbb{F}$的元素。


* 矩阵中列的个数是固定的。列可能是***fixed***、***advice或者instance***。固定列在电路中是固定的；advice列是论据信息；instance列通常用作公开输入（技术上讲, 它们可以是证明者和验证者之间共享的任何元素）。

* 一些列参与相等约束。


* 多项式阶的范围。

* 一系列***多项式约束***。这些多项式*每一行*在 $\mathbb{F}$ 上的取值为零。多项式约束中的变量可以是给定列当前行中的单元格，也可以是给定列中与这行相关的行（比如模$n$)。每个多项式的最高阶由多项式阶的范围限定。
  
* 一系列的查找表论据，定义了查找表的输入和查找表相关的列。

PLONK化电路还定义:

* 矩阵的行数为 $n$。$n$ 必须对应于$\mathbb{F}^\times$的乘法子群的大小；通常是2的幂次。

* 一系列***相等约束***，指定两个给定单元格必须具有相等的值。

* 固定列中每行的固定值。

根据电路，我们可以生成电路证明和验证操作所需要的***证明密钥*** 和***验证密钥***。

> 请注意，我们指定了列的顺序、多项式约束、查找表论据和相等约束，这些并不影响电路的含义。但这些使得证明和验证密钥的确定性的生成过程变得更加容易。

通常，配置将定义多项式约束，这些约束由定义在固定列中的***选择子***关闭和开启。例如，一个约束 $q_i \cdot p(...) = 0$ 可以通过在第i行设置$q_i = 0$来关闭。在这种情况下，我们通常将多个选择子控制的一组约束，称一个***门（gate）***。通常***标准门***支持一些通用操作，比如域上的乘法和除法， ***自定义门***支持更专门的操作。
